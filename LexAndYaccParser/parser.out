Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> expr
Rule 2     program -> program error expr
Rule 3     program -> error expr
Rule 4     expr -> expr + expr
Rule 5     expr -> expr - expr
Rule 6     expr -> expr * expr
Rule 7     expr -> expr / expr
Rule 8     expr -> expr NEQ expr
Rule 9     expr -> expr LE expr
Rule 10    expr -> expr GE expr
Rule 11    expr -> expr = expr
Rule 12    expr -> expr < expr
Rule 13    expr -> expr > expr
Rule 14    expr -> expr | expr
Rule 15    expr -> expr & expr
Rule 16    expr -> NIL
Rule 17    expr -> BREAK
Rule 18    expr -> - expr
Rule 19    expr -> INT
Rule 20    expr -> STRING
Rule 21    expr -> lvalue
Rule 22    lvalue -> ID
Rule 23    lvalue -> complexLValue
Rule 24    complexLValue -> subscript
Rule 25    complexLValue -> fieldExp
Rule 26    subscript -> complexLValue [ expr ]
Rule 27    subscript -> ID [ expr ]
Rule 28    fieldExp -> lvalue . ID
Rule 29    expr -> lvalue ASSIGN expr
Rule 30    expr -> ( exprSemiStar )
Rule 31    expr -> ID ( exprCommaStar )
Rule 32    expr -> ID [ expr ] OF expr
Rule 33    expr -> ID { fieldCreateCommaStar }
Rule 34    fieldCreate -> ID = expr
Rule 35    expr -> IF expr THEN expr
Rule 36    expr -> IF expr THEN expr ELSE expr
Rule 37    expr -> WHILE expr DO expr
Rule 38    expr -> FOR ID ASSIGN expr TO expr DO expr
Rule 39    expr -> LET decPlus IN exprSemiStar END
Rule 40    dec -> TYPE ID = ty
Rule 41    dec -> VAR ID ASSIGN expr
Rule 42    dec -> VAR ID : ID ASSIGN expr
Rule 43    dec -> FUNCTION ID ( fieldDecCommaStar ) = expr
Rule 44    dec -> FUNCTION ID ( fieldDecCommaStar ) : ID = expr
Rule 45    ty -> ID
Rule 46    ty -> ARRAY OF ID
Rule 47    ty -> { fieldDecCommaStar }
Rule 48    fieldDec -> ID : ID
Rule 49    fieldDecCommaStar -> <empty>
Rule 50    fieldDecCommaStar -> fieldDecCommaPlus
Rule 51    fieldDecCommaPlus -> fieldDec
Rule 52    fieldDecCommaPlus -> fieldDecCommaPlus , fieldDec
Rule 53    decPlus -> dec
Rule 54    decPlus -> error
Rule 55    decPlus -> decPlus dec
Rule 56    decPlus -> decPlus error
Rule 57    fieldCreateCommaStar -> <empty>
Rule 58    fieldCreateCommaStar -> fieldCreateCommaPlus
Rule 59    fieldCreateCommaPlus -> fieldCreate
Rule 60    fieldCreateCommaPlus -> fieldCreateCommaPlus , fieldCreate
Rule 61    exprSemiStar -> <empty>
Rule 62    exprSemiStar -> exprSemiPlus
Rule 63    exprSemiPlus -> expr
Rule 64    exprSemiPlus -> error
Rule 65    exprSemiPlus -> exprSemiPlus ; expr
Rule 66    exprSemiPlus -> exprSemiPlus error
Rule 67    exprCommaStar -> <empty>
Rule 68    exprCommaStar -> exprCommaPlus
Rule 69    exprCommaPlus -> expr
Rule 70    exprCommaPlus -> exprCommaPlus , expr

Terminals, with rules where they appear

&                    : 15
(                    : 30 31 43 44
)                    : 30 31 43 44
*                    : 6
+                    : 4
,                    : 52 60 70
-                    : 5 18
.                    : 28
/                    : 7
:                    : 42 44 48
;                    : 65
<                    : 12
=                    : 11 34 40 43 44
>                    : 13
ARRAY                : 46
ASSIGN               : 29 38 41 42
BREAK                : 17
DO                   : 37 38
ELSE                 : 36
END                  : 39
FOR                  : 38
FUNCTION             : 43 44
GE                   : 10
ID                   : 22 27 28 31 32 33 34 38 40 41 42 42 43 44 44 45 46 48 48
IF                   : 35 36
IN                   : 39
INT                  : 19
LE                   : 9
LET                  : 39
NEQ                  : 8
NIL                  : 16
OF                   : 32 46
STRING               : 20
THEN                 : 35 36
TO                   : 38
TYPE                 : 40
VAR                  : 41 42
WHILE                : 37
[                    : 26 27 32
]                    : 26 27 32
error                : 2 3 54 56 64 66
{                    : 33 47
|                    : 14
}                    : 33 47

Nonterminals, with rules where they appear

complexLValue        : 23 26
dec                  : 53 55
decPlus              : 39 55 56
expr                 : 1 2 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13 14 14 15 15 18 26 27 29 32 32 34 35 35 36 36 36 37 37 38 38 38 41 42 43 44 63 65 69 70
exprCommaPlus        : 68 70
exprCommaStar        : 31
exprSemiPlus         : 62 65 66
exprSemiStar         : 30 39
fieldCreate          : 59 60
fieldCreateCommaPlus : 58 60
fieldCreateCommaStar : 33
fieldDec             : 51 52
fieldDecCommaPlus    : 50 52
fieldDecCommaStar    : 43 44 47
fieldExp             : 25
lvalue               : 21 28 29
program              : 2 0
subscript            : 24
ty                   : 40

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . expr
    (2) program -> . program error expr
    (3) program -> . error expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    error           shift and go to state 3
    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    program                        shift and go to state 1
    expr                           shift and go to state 2
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 1

    (0) S' -> program .
    (2) program -> program . error expr

    error           shift and go to state 19


state 2

    (1) program -> expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    error           reduce using rule 1 (program -> expr .)
    $end            reduce using rule 1 (program -> expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 3

    (3) program -> error . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 32
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 4

    (18) expr -> - . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 33
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 5

    (16) expr -> NIL .

    +               reduce using rule 16 (expr -> NIL .)
    -               reduce using rule 16 (expr -> NIL .)
    *               reduce using rule 16 (expr -> NIL .)
    /               reduce using rule 16 (expr -> NIL .)
    NEQ             reduce using rule 16 (expr -> NIL .)
    LE              reduce using rule 16 (expr -> NIL .)
    GE              reduce using rule 16 (expr -> NIL .)
    =               reduce using rule 16 (expr -> NIL .)
    <               reduce using rule 16 (expr -> NIL .)
    >               reduce using rule 16 (expr -> NIL .)
    |               reduce using rule 16 (expr -> NIL .)
    &               reduce using rule 16 (expr -> NIL .)
    error           reduce using rule 16 (expr -> NIL .)
    $end            reduce using rule 16 (expr -> NIL .)
    ;               reduce using rule 16 (expr -> NIL .)
    )               reduce using rule 16 (expr -> NIL .)
    THEN            reduce using rule 16 (expr -> NIL .)
    DO              reduce using rule 16 (expr -> NIL .)
    ,               reduce using rule 16 (expr -> NIL .)
    ]               reduce using rule 16 (expr -> NIL .)
    END             reduce using rule 16 (expr -> NIL .)
    ELSE            reduce using rule 16 (expr -> NIL .)
    TO              reduce using rule 16 (expr -> NIL .)
    }               reduce using rule 16 (expr -> NIL .)
    IN              reduce using rule 16 (expr -> NIL .)
    TYPE            reduce using rule 16 (expr -> NIL .)
    VAR             reduce using rule 16 (expr -> NIL .)
    FUNCTION        reduce using rule 16 (expr -> NIL .)


state 6

    (17) expr -> BREAK .

    +               reduce using rule 17 (expr -> BREAK .)
    -               reduce using rule 17 (expr -> BREAK .)
    *               reduce using rule 17 (expr -> BREAK .)
    /               reduce using rule 17 (expr -> BREAK .)
    NEQ             reduce using rule 17 (expr -> BREAK .)
    LE              reduce using rule 17 (expr -> BREAK .)
    GE              reduce using rule 17 (expr -> BREAK .)
    =               reduce using rule 17 (expr -> BREAK .)
    <               reduce using rule 17 (expr -> BREAK .)
    >               reduce using rule 17 (expr -> BREAK .)
    |               reduce using rule 17 (expr -> BREAK .)
    &               reduce using rule 17 (expr -> BREAK .)
    error           reduce using rule 17 (expr -> BREAK .)
    $end            reduce using rule 17 (expr -> BREAK .)
    ;               reduce using rule 17 (expr -> BREAK .)
    )               reduce using rule 17 (expr -> BREAK .)
    THEN            reduce using rule 17 (expr -> BREAK .)
    DO              reduce using rule 17 (expr -> BREAK .)
    ,               reduce using rule 17 (expr -> BREAK .)
    ]               reduce using rule 17 (expr -> BREAK .)
    END             reduce using rule 17 (expr -> BREAK .)
    ELSE            reduce using rule 17 (expr -> BREAK .)
    TO              reduce using rule 17 (expr -> BREAK .)
    }               reduce using rule 17 (expr -> BREAK .)
    IN              reduce using rule 17 (expr -> BREAK .)
    TYPE            reduce using rule 17 (expr -> BREAK .)
    VAR             reduce using rule 17 (expr -> BREAK .)
    FUNCTION        reduce using rule 17 (expr -> BREAK .)


state 7

    (19) expr -> INT .

    +               reduce using rule 19 (expr -> INT .)
    -               reduce using rule 19 (expr -> INT .)
    *               reduce using rule 19 (expr -> INT .)
    /               reduce using rule 19 (expr -> INT .)
    NEQ             reduce using rule 19 (expr -> INT .)
    LE              reduce using rule 19 (expr -> INT .)
    GE              reduce using rule 19 (expr -> INT .)
    =               reduce using rule 19 (expr -> INT .)
    <               reduce using rule 19 (expr -> INT .)
    >               reduce using rule 19 (expr -> INT .)
    |               reduce using rule 19 (expr -> INT .)
    &               reduce using rule 19 (expr -> INT .)
    error           reduce using rule 19 (expr -> INT .)
    $end            reduce using rule 19 (expr -> INT .)
    ;               reduce using rule 19 (expr -> INT .)
    )               reduce using rule 19 (expr -> INT .)
    THEN            reduce using rule 19 (expr -> INT .)
    DO              reduce using rule 19 (expr -> INT .)
    ,               reduce using rule 19 (expr -> INT .)
    ]               reduce using rule 19 (expr -> INT .)
    END             reduce using rule 19 (expr -> INT .)
    ELSE            reduce using rule 19 (expr -> INT .)
    TO              reduce using rule 19 (expr -> INT .)
    }               reduce using rule 19 (expr -> INT .)
    IN              reduce using rule 19 (expr -> INT .)
    TYPE            reduce using rule 19 (expr -> INT .)
    VAR             reduce using rule 19 (expr -> INT .)
    FUNCTION        reduce using rule 19 (expr -> INT .)


state 8

    (20) expr -> STRING .

    +               reduce using rule 20 (expr -> STRING .)
    -               reduce using rule 20 (expr -> STRING .)
    *               reduce using rule 20 (expr -> STRING .)
    /               reduce using rule 20 (expr -> STRING .)
    NEQ             reduce using rule 20 (expr -> STRING .)
    LE              reduce using rule 20 (expr -> STRING .)
    GE              reduce using rule 20 (expr -> STRING .)
    =               reduce using rule 20 (expr -> STRING .)
    <               reduce using rule 20 (expr -> STRING .)
    >               reduce using rule 20 (expr -> STRING .)
    |               reduce using rule 20 (expr -> STRING .)
    &               reduce using rule 20 (expr -> STRING .)
    error           reduce using rule 20 (expr -> STRING .)
    $end            reduce using rule 20 (expr -> STRING .)
    ;               reduce using rule 20 (expr -> STRING .)
    )               reduce using rule 20 (expr -> STRING .)
    THEN            reduce using rule 20 (expr -> STRING .)
    DO              reduce using rule 20 (expr -> STRING .)
    ,               reduce using rule 20 (expr -> STRING .)
    ]               reduce using rule 20 (expr -> STRING .)
    END             reduce using rule 20 (expr -> STRING .)
    ELSE            reduce using rule 20 (expr -> STRING .)
    TO              reduce using rule 20 (expr -> STRING .)
    }               reduce using rule 20 (expr -> STRING .)
    IN              reduce using rule 20 (expr -> STRING .)
    TYPE            reduce using rule 20 (expr -> STRING .)
    VAR             reduce using rule 20 (expr -> STRING .)
    FUNCTION        reduce using rule 20 (expr -> STRING .)


state 9

    (21) expr -> lvalue .
    (29) expr -> lvalue . ASSIGN expr
    (28) fieldExp -> lvalue . . ID

    +               reduce using rule 21 (expr -> lvalue .)
    -               reduce using rule 21 (expr -> lvalue .)
    *               reduce using rule 21 (expr -> lvalue .)
    /               reduce using rule 21 (expr -> lvalue .)
    NEQ             reduce using rule 21 (expr -> lvalue .)
    LE              reduce using rule 21 (expr -> lvalue .)
    GE              reduce using rule 21 (expr -> lvalue .)
    =               reduce using rule 21 (expr -> lvalue .)
    <               reduce using rule 21 (expr -> lvalue .)
    >               reduce using rule 21 (expr -> lvalue .)
    |               reduce using rule 21 (expr -> lvalue .)
    &               reduce using rule 21 (expr -> lvalue .)
    error           reduce using rule 21 (expr -> lvalue .)
    $end            reduce using rule 21 (expr -> lvalue .)
    ;               reduce using rule 21 (expr -> lvalue .)
    )               reduce using rule 21 (expr -> lvalue .)
    THEN            reduce using rule 21 (expr -> lvalue .)
    DO              reduce using rule 21 (expr -> lvalue .)
    ,               reduce using rule 21 (expr -> lvalue .)
    ]               reduce using rule 21 (expr -> lvalue .)
    END             reduce using rule 21 (expr -> lvalue .)
    ELSE            reduce using rule 21 (expr -> lvalue .)
    TO              reduce using rule 21 (expr -> lvalue .)
    }               reduce using rule 21 (expr -> lvalue .)
    IN              reduce using rule 21 (expr -> lvalue .)
    TYPE            reduce using rule 21 (expr -> lvalue .)
    VAR             reduce using rule 21 (expr -> lvalue .)
    FUNCTION        reduce using rule 21 (expr -> lvalue .)
    ASSIGN          shift and go to state 34
    .               shift and go to state 35


state 10

    (30) expr -> ( . exprSemiStar )
    (61) exprSemiStar -> .
    (62) exprSemiStar -> . exprSemiPlus
    (63) exprSemiPlus -> . expr
    (64) exprSemiPlus -> . error
    (65) exprSemiPlus -> . exprSemiPlus ; expr
    (66) exprSemiPlus -> . exprSemiPlus error
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    )               reduce using rule 61 (exprSemiStar -> .)
    error           shift and go to state 39
    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    exprSemiStar                   shift and go to state 36
    exprSemiPlus                   shift and go to state 37
    expr                           shift and go to state 38
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 11

    (31) expr -> ID . ( exprCommaStar )
    (32) expr -> ID . [ expr ] OF expr
    (33) expr -> ID . { fieldCreateCommaStar }
    (22) lvalue -> ID .
    (27) subscript -> ID . [ expr ]

    (               shift and go to state 40
    [               shift and go to state 41
    {               shift and go to state 42
    ASSIGN          reduce using rule 22 (lvalue -> ID .)
    .               reduce using rule 22 (lvalue -> ID .)
    +               reduce using rule 22 (lvalue -> ID .)
    -               reduce using rule 22 (lvalue -> ID .)
    *               reduce using rule 22 (lvalue -> ID .)
    /               reduce using rule 22 (lvalue -> ID .)
    NEQ             reduce using rule 22 (lvalue -> ID .)
    LE              reduce using rule 22 (lvalue -> ID .)
    GE              reduce using rule 22 (lvalue -> ID .)
    =               reduce using rule 22 (lvalue -> ID .)
    <               reduce using rule 22 (lvalue -> ID .)
    >               reduce using rule 22 (lvalue -> ID .)
    |               reduce using rule 22 (lvalue -> ID .)
    &               reduce using rule 22 (lvalue -> ID .)
    error           reduce using rule 22 (lvalue -> ID .)
    $end            reduce using rule 22 (lvalue -> ID .)
    ;               reduce using rule 22 (lvalue -> ID .)
    )               reduce using rule 22 (lvalue -> ID .)
    THEN            reduce using rule 22 (lvalue -> ID .)
    DO              reduce using rule 22 (lvalue -> ID .)
    ,               reduce using rule 22 (lvalue -> ID .)
    ]               reduce using rule 22 (lvalue -> ID .)
    END             reduce using rule 22 (lvalue -> ID .)
    ELSE            reduce using rule 22 (lvalue -> ID .)
    TO              reduce using rule 22 (lvalue -> ID .)
    }               reduce using rule 22 (lvalue -> ID .)
    IN              reduce using rule 22 (lvalue -> ID .)
    TYPE            reduce using rule 22 (lvalue -> ID .)
    VAR             reduce using rule 22 (lvalue -> ID .)
    FUNCTION        reduce using rule 22 (lvalue -> ID .)


state 12

    (35) expr -> IF . expr THEN expr
    (36) expr -> IF . expr THEN expr ELSE expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 43
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 13

    (37) expr -> WHILE . expr DO expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 44
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 14

    (38) expr -> FOR . ID ASSIGN expr TO expr DO expr

    ID              shift and go to state 45


state 15

    (39) expr -> LET . decPlus IN exprSemiStar END
    (53) decPlus -> . dec
    (54) decPlus -> . error
    (55) decPlus -> . decPlus dec
    (56) decPlus -> . decPlus error
    (40) dec -> . TYPE ID = ty
    (41) dec -> . VAR ID ASSIGN expr
    (42) dec -> . VAR ID : ID ASSIGN expr
    (43) dec -> . FUNCTION ID ( fieldDecCommaStar ) = expr
    (44) dec -> . FUNCTION ID ( fieldDecCommaStar ) : ID = expr

    error           shift and go to state 48
    TYPE            shift and go to state 49
    VAR             shift and go to state 50
    FUNCTION        shift and go to state 51

    decPlus                        shift and go to state 46
    dec                            shift and go to state 47

state 16

    (23) lvalue -> complexLValue .
    (26) subscript -> complexLValue . [ expr ]

    ASSIGN          reduce using rule 23 (lvalue -> complexLValue .)
    .               reduce using rule 23 (lvalue -> complexLValue .)
    +               reduce using rule 23 (lvalue -> complexLValue .)
    -               reduce using rule 23 (lvalue -> complexLValue .)
    *               reduce using rule 23 (lvalue -> complexLValue .)
    /               reduce using rule 23 (lvalue -> complexLValue .)
    NEQ             reduce using rule 23 (lvalue -> complexLValue .)
    LE              reduce using rule 23 (lvalue -> complexLValue .)
    GE              reduce using rule 23 (lvalue -> complexLValue .)
    =               reduce using rule 23 (lvalue -> complexLValue .)
    <               reduce using rule 23 (lvalue -> complexLValue .)
    >               reduce using rule 23 (lvalue -> complexLValue .)
    |               reduce using rule 23 (lvalue -> complexLValue .)
    &               reduce using rule 23 (lvalue -> complexLValue .)
    error           reduce using rule 23 (lvalue -> complexLValue .)
    $end            reduce using rule 23 (lvalue -> complexLValue .)
    ;               reduce using rule 23 (lvalue -> complexLValue .)
    )               reduce using rule 23 (lvalue -> complexLValue .)
    THEN            reduce using rule 23 (lvalue -> complexLValue .)
    DO              reduce using rule 23 (lvalue -> complexLValue .)
    ,               reduce using rule 23 (lvalue -> complexLValue .)
    ]               reduce using rule 23 (lvalue -> complexLValue .)
    END             reduce using rule 23 (lvalue -> complexLValue .)
    ELSE            reduce using rule 23 (lvalue -> complexLValue .)
    TO              reduce using rule 23 (lvalue -> complexLValue .)
    }               reduce using rule 23 (lvalue -> complexLValue .)
    IN              reduce using rule 23 (lvalue -> complexLValue .)
    TYPE            reduce using rule 23 (lvalue -> complexLValue .)
    VAR             reduce using rule 23 (lvalue -> complexLValue .)
    FUNCTION        reduce using rule 23 (lvalue -> complexLValue .)
    [               shift and go to state 52


state 17

    (24) complexLValue -> subscript .

    [               reduce using rule 24 (complexLValue -> subscript .)
    ASSIGN          reduce using rule 24 (complexLValue -> subscript .)
    .               reduce using rule 24 (complexLValue -> subscript .)
    +               reduce using rule 24 (complexLValue -> subscript .)
    -               reduce using rule 24 (complexLValue -> subscript .)
    *               reduce using rule 24 (complexLValue -> subscript .)
    /               reduce using rule 24 (complexLValue -> subscript .)
    NEQ             reduce using rule 24 (complexLValue -> subscript .)
    LE              reduce using rule 24 (complexLValue -> subscript .)
    GE              reduce using rule 24 (complexLValue -> subscript .)
    =               reduce using rule 24 (complexLValue -> subscript .)
    <               reduce using rule 24 (complexLValue -> subscript .)
    >               reduce using rule 24 (complexLValue -> subscript .)
    |               reduce using rule 24 (complexLValue -> subscript .)
    &               reduce using rule 24 (complexLValue -> subscript .)
    error           reduce using rule 24 (complexLValue -> subscript .)
    $end            reduce using rule 24 (complexLValue -> subscript .)
    ;               reduce using rule 24 (complexLValue -> subscript .)
    )               reduce using rule 24 (complexLValue -> subscript .)
    THEN            reduce using rule 24 (complexLValue -> subscript .)
    DO              reduce using rule 24 (complexLValue -> subscript .)
    ,               reduce using rule 24 (complexLValue -> subscript .)
    ]               reduce using rule 24 (complexLValue -> subscript .)
    END             reduce using rule 24 (complexLValue -> subscript .)
    ELSE            reduce using rule 24 (complexLValue -> subscript .)
    TO              reduce using rule 24 (complexLValue -> subscript .)
    }               reduce using rule 24 (complexLValue -> subscript .)
    IN              reduce using rule 24 (complexLValue -> subscript .)
    TYPE            reduce using rule 24 (complexLValue -> subscript .)
    VAR             reduce using rule 24 (complexLValue -> subscript .)
    FUNCTION        reduce using rule 24 (complexLValue -> subscript .)


state 18

    (25) complexLValue -> fieldExp .

    [               reduce using rule 25 (complexLValue -> fieldExp .)
    ASSIGN          reduce using rule 25 (complexLValue -> fieldExp .)
    .               reduce using rule 25 (complexLValue -> fieldExp .)
    +               reduce using rule 25 (complexLValue -> fieldExp .)
    -               reduce using rule 25 (complexLValue -> fieldExp .)
    *               reduce using rule 25 (complexLValue -> fieldExp .)
    /               reduce using rule 25 (complexLValue -> fieldExp .)
    NEQ             reduce using rule 25 (complexLValue -> fieldExp .)
    LE              reduce using rule 25 (complexLValue -> fieldExp .)
    GE              reduce using rule 25 (complexLValue -> fieldExp .)
    =               reduce using rule 25 (complexLValue -> fieldExp .)
    <               reduce using rule 25 (complexLValue -> fieldExp .)
    >               reduce using rule 25 (complexLValue -> fieldExp .)
    |               reduce using rule 25 (complexLValue -> fieldExp .)
    &               reduce using rule 25 (complexLValue -> fieldExp .)
    error           reduce using rule 25 (complexLValue -> fieldExp .)
    $end            reduce using rule 25 (complexLValue -> fieldExp .)
    ;               reduce using rule 25 (complexLValue -> fieldExp .)
    )               reduce using rule 25 (complexLValue -> fieldExp .)
    THEN            reduce using rule 25 (complexLValue -> fieldExp .)
    DO              reduce using rule 25 (complexLValue -> fieldExp .)
    ,               reduce using rule 25 (complexLValue -> fieldExp .)
    ]               reduce using rule 25 (complexLValue -> fieldExp .)
    END             reduce using rule 25 (complexLValue -> fieldExp .)
    ELSE            reduce using rule 25 (complexLValue -> fieldExp .)
    TO              reduce using rule 25 (complexLValue -> fieldExp .)
    }               reduce using rule 25 (complexLValue -> fieldExp .)
    IN              reduce using rule 25 (complexLValue -> fieldExp .)
    TYPE            reduce using rule 25 (complexLValue -> fieldExp .)
    VAR             reduce using rule 25 (complexLValue -> fieldExp .)
    FUNCTION        reduce using rule 25 (complexLValue -> fieldExp .)


state 19

    (2) program -> program error . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 53
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 20

    (4) expr -> expr + . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 54
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 21

    (5) expr -> expr - . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 55
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 22

    (6) expr -> expr * . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 56
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 23

    (7) expr -> expr / . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 57
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 24

    (8) expr -> expr NEQ . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 58
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 25

    (9) expr -> expr LE . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 59
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 26

    (10) expr -> expr GE . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 60
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 27

    (11) expr -> expr = . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 61
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 28

    (12) expr -> expr < . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 62
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 29

    (13) expr -> expr > . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 63
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 30

    (14) expr -> expr | . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 64
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 31

    (15) expr -> expr & . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 65
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 32

    (3) program -> error expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    error           reduce using rule 3 (program -> error expr .)
    $end            reduce using rule 3 (program -> error expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 33

    (18) expr -> - expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    +               reduce using rule 18 (expr -> - expr .)
    -               reduce using rule 18 (expr -> - expr .)
    *               reduce using rule 18 (expr -> - expr .)
    /               reduce using rule 18 (expr -> - expr .)
    NEQ             reduce using rule 18 (expr -> - expr .)
    LE              reduce using rule 18 (expr -> - expr .)
    GE              reduce using rule 18 (expr -> - expr .)
    =               reduce using rule 18 (expr -> - expr .)
    <               reduce using rule 18 (expr -> - expr .)
    >               reduce using rule 18 (expr -> - expr .)
    |               reduce using rule 18 (expr -> - expr .)
    &               reduce using rule 18 (expr -> - expr .)
    error           reduce using rule 18 (expr -> - expr .)
    $end            reduce using rule 18 (expr -> - expr .)
    ;               reduce using rule 18 (expr -> - expr .)
    )               reduce using rule 18 (expr -> - expr .)
    THEN            reduce using rule 18 (expr -> - expr .)
    DO              reduce using rule 18 (expr -> - expr .)
    ,               reduce using rule 18 (expr -> - expr .)
    ]               reduce using rule 18 (expr -> - expr .)
    END             reduce using rule 18 (expr -> - expr .)
    ELSE            reduce using rule 18 (expr -> - expr .)
    TO              reduce using rule 18 (expr -> - expr .)
    }               reduce using rule 18 (expr -> - expr .)
    IN              reduce using rule 18 (expr -> - expr .)
    TYPE            reduce using rule 18 (expr -> - expr .)
    VAR             reduce using rule 18 (expr -> - expr .)
    FUNCTION        reduce using rule 18 (expr -> - expr .)

  ! +               [ shift and go to state 20 ]
  ! -               [ shift and go to state 21 ]
  ! *               [ shift and go to state 22 ]
  ! /               [ shift and go to state 23 ]
  ! NEQ             [ shift and go to state 24 ]
  ! LE              [ shift and go to state 25 ]
  ! GE              [ shift and go to state 26 ]
  ! =               [ shift and go to state 27 ]
  ! <               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 34

    (29) expr -> lvalue ASSIGN . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    lvalue                         shift and go to state 9
    expr                           shift and go to state 66
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 35

    (28) fieldExp -> lvalue . . ID

    ID              shift and go to state 67


state 36

    (30) expr -> ( exprSemiStar . )

    )               shift and go to state 68


state 37

    (62) exprSemiStar -> exprSemiPlus .
    (65) exprSemiPlus -> exprSemiPlus . ; expr
    (66) exprSemiPlus -> exprSemiPlus . error

    )               reduce using rule 62 (exprSemiStar -> exprSemiPlus .)
    END             reduce using rule 62 (exprSemiStar -> exprSemiPlus .)
    ;               shift and go to state 69
    error           shift and go to state 70


state 38

    (63) exprSemiPlus -> expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    ;               reduce using rule 63 (exprSemiPlus -> expr .)
    error           reduce using rule 63 (exprSemiPlus -> expr .)
    )               reduce using rule 63 (exprSemiPlus -> expr .)
    END             reduce using rule 63 (exprSemiPlus -> expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 39

    (64) exprSemiPlus -> error .

    ;               reduce using rule 64 (exprSemiPlus -> error .)
    error           reduce using rule 64 (exprSemiPlus -> error .)
    )               reduce using rule 64 (exprSemiPlus -> error .)
    END             reduce using rule 64 (exprSemiPlus -> error .)


state 40

    (31) expr -> ID ( . exprCommaStar )
    (67) exprCommaStar -> .
    (68) exprCommaStar -> . exprCommaPlus
    (69) exprCommaPlus -> . expr
    (70) exprCommaPlus -> . exprCommaPlus , expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    )               reduce using rule 67 (exprCommaStar -> .)
    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    exprCommaStar                  shift and go to state 71
    exprCommaPlus                  shift and go to state 72
    expr                           shift and go to state 73
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 41

    (32) expr -> ID [ . expr ] OF expr
    (27) subscript -> ID [ . expr ]
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 74
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 42

    (33) expr -> ID { . fieldCreateCommaStar }
    (57) fieldCreateCommaStar -> .
    (58) fieldCreateCommaStar -> . fieldCreateCommaPlus
    (59) fieldCreateCommaPlus -> . fieldCreate
    (60) fieldCreateCommaPlus -> . fieldCreateCommaPlus , fieldCreate
    (34) fieldCreate -> . ID = expr

    }               reduce using rule 57 (fieldCreateCommaStar -> .)
    ID              shift and go to state 75

    fieldCreateCommaStar           shift and go to state 76
    fieldCreateCommaPlus           shift and go to state 77
    fieldCreate                    shift and go to state 78

state 43

    (35) expr -> IF expr . THEN expr
    (36) expr -> IF expr . THEN expr ELSE expr
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    THEN            shift and go to state 79
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 44

    (37) expr -> WHILE expr . DO expr
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    DO              shift and go to state 80
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 45

    (38) expr -> FOR ID . ASSIGN expr TO expr DO expr

    ASSIGN          shift and go to state 81


state 46

    (39) expr -> LET decPlus . IN exprSemiStar END
    (55) decPlus -> decPlus . dec
    (56) decPlus -> decPlus . error
    (40) dec -> . TYPE ID = ty
    (41) dec -> . VAR ID ASSIGN expr
    (42) dec -> . VAR ID : ID ASSIGN expr
    (43) dec -> . FUNCTION ID ( fieldDecCommaStar ) = expr
    (44) dec -> . FUNCTION ID ( fieldDecCommaStar ) : ID = expr

    IN              shift and go to state 82
    error           shift and go to state 84
    TYPE            shift and go to state 49
    VAR             shift and go to state 50
    FUNCTION        shift and go to state 51

    dec                            shift and go to state 83

state 47

    (53) decPlus -> dec .

    IN              reduce using rule 53 (decPlus -> dec .)
    error           reduce using rule 53 (decPlus -> dec .)
    TYPE            reduce using rule 53 (decPlus -> dec .)
    VAR             reduce using rule 53 (decPlus -> dec .)
    FUNCTION        reduce using rule 53 (decPlus -> dec .)


state 48

    (54) decPlus -> error .

    IN              reduce using rule 54 (decPlus -> error .)
    error           reduce using rule 54 (decPlus -> error .)
    TYPE            reduce using rule 54 (decPlus -> error .)
    VAR             reduce using rule 54 (decPlus -> error .)
    FUNCTION        reduce using rule 54 (decPlus -> error .)


state 49

    (40) dec -> TYPE . ID = ty

    ID              shift and go to state 85


state 50

    (41) dec -> VAR . ID ASSIGN expr
    (42) dec -> VAR . ID : ID ASSIGN expr

    ID              shift and go to state 86


state 51

    (43) dec -> FUNCTION . ID ( fieldDecCommaStar ) = expr
    (44) dec -> FUNCTION . ID ( fieldDecCommaStar ) : ID = expr

    ID              shift and go to state 87


state 52

    (26) subscript -> complexLValue [ . expr ]
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    complexLValue                  shift and go to state 16
    expr                           shift and go to state 88
    lvalue                         shift and go to state 9
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 53

    (2) program -> program error expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    error           reduce using rule 2 (program -> program error expr .)
    $end            reduce using rule 2 (program -> program error expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 54

    (4) expr -> expr + expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    +               reduce using rule 4 (expr -> expr + expr .)
    -               reduce using rule 4 (expr -> expr + expr .)
    NEQ             reduce using rule 4 (expr -> expr + expr .)
    LE              reduce using rule 4 (expr -> expr + expr .)
    GE              reduce using rule 4 (expr -> expr + expr .)
    =               reduce using rule 4 (expr -> expr + expr .)
    <               reduce using rule 4 (expr -> expr + expr .)
    >               reduce using rule 4 (expr -> expr + expr .)
    |               reduce using rule 4 (expr -> expr + expr .)
    &               reduce using rule 4 (expr -> expr + expr .)
    error           reduce using rule 4 (expr -> expr + expr .)
    $end            reduce using rule 4 (expr -> expr + expr .)
    ;               reduce using rule 4 (expr -> expr + expr .)
    )               reduce using rule 4 (expr -> expr + expr .)
    THEN            reduce using rule 4 (expr -> expr + expr .)
    DO              reduce using rule 4 (expr -> expr + expr .)
    ,               reduce using rule 4 (expr -> expr + expr .)
    ]               reduce using rule 4 (expr -> expr + expr .)
    END             reduce using rule 4 (expr -> expr + expr .)
    ELSE            reduce using rule 4 (expr -> expr + expr .)
    TO              reduce using rule 4 (expr -> expr + expr .)
    }               reduce using rule 4 (expr -> expr + expr .)
    IN              reduce using rule 4 (expr -> expr + expr .)
    TYPE            reduce using rule 4 (expr -> expr + expr .)
    VAR             reduce using rule 4 (expr -> expr + expr .)
    FUNCTION        reduce using rule 4 (expr -> expr + expr .)
    *               shift and go to state 22
    /               shift and go to state 23

  ! *               [ reduce using rule 4 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 4 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 20 ]
  ! -               [ shift and go to state 21 ]
  ! NEQ             [ shift and go to state 24 ]
  ! LE              [ shift and go to state 25 ]
  ! GE              [ shift and go to state 26 ]
  ! =               [ shift and go to state 27 ]
  ! <               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 55

    (5) expr -> expr - expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    +               reduce using rule 5 (expr -> expr - expr .)
    -               reduce using rule 5 (expr -> expr - expr .)
    NEQ             reduce using rule 5 (expr -> expr - expr .)
    LE              reduce using rule 5 (expr -> expr - expr .)
    GE              reduce using rule 5 (expr -> expr - expr .)
    =               reduce using rule 5 (expr -> expr - expr .)
    <               reduce using rule 5 (expr -> expr - expr .)
    >               reduce using rule 5 (expr -> expr - expr .)
    |               reduce using rule 5 (expr -> expr - expr .)
    &               reduce using rule 5 (expr -> expr - expr .)
    error           reduce using rule 5 (expr -> expr - expr .)
    $end            reduce using rule 5 (expr -> expr - expr .)
    ;               reduce using rule 5 (expr -> expr - expr .)
    )               reduce using rule 5 (expr -> expr - expr .)
    THEN            reduce using rule 5 (expr -> expr - expr .)
    DO              reduce using rule 5 (expr -> expr - expr .)
    ,               reduce using rule 5 (expr -> expr - expr .)
    ]               reduce using rule 5 (expr -> expr - expr .)
    END             reduce using rule 5 (expr -> expr - expr .)
    ELSE            reduce using rule 5 (expr -> expr - expr .)
    TO              reduce using rule 5 (expr -> expr - expr .)
    }               reduce using rule 5 (expr -> expr - expr .)
    IN              reduce using rule 5 (expr -> expr - expr .)
    TYPE            reduce using rule 5 (expr -> expr - expr .)
    VAR             reduce using rule 5 (expr -> expr - expr .)
    FUNCTION        reduce using rule 5 (expr -> expr - expr .)
    *               shift and go to state 22
    /               shift and go to state 23

  ! *               [ reduce using rule 5 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 5 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 20 ]
  ! -               [ shift and go to state 21 ]
  ! NEQ             [ shift and go to state 24 ]
  ! LE              [ shift and go to state 25 ]
  ! GE              [ shift and go to state 26 ]
  ! =               [ shift and go to state 27 ]
  ! <               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 56

    (6) expr -> expr * expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    +               reduce using rule 6 (expr -> expr * expr .)
    -               reduce using rule 6 (expr -> expr * expr .)
    *               reduce using rule 6 (expr -> expr * expr .)
    /               reduce using rule 6 (expr -> expr * expr .)
    NEQ             reduce using rule 6 (expr -> expr * expr .)
    LE              reduce using rule 6 (expr -> expr * expr .)
    GE              reduce using rule 6 (expr -> expr * expr .)
    =               reduce using rule 6 (expr -> expr * expr .)
    <               reduce using rule 6 (expr -> expr * expr .)
    >               reduce using rule 6 (expr -> expr * expr .)
    |               reduce using rule 6 (expr -> expr * expr .)
    &               reduce using rule 6 (expr -> expr * expr .)
    error           reduce using rule 6 (expr -> expr * expr .)
    $end            reduce using rule 6 (expr -> expr * expr .)
    ;               reduce using rule 6 (expr -> expr * expr .)
    )               reduce using rule 6 (expr -> expr * expr .)
    THEN            reduce using rule 6 (expr -> expr * expr .)
    DO              reduce using rule 6 (expr -> expr * expr .)
    ,               reduce using rule 6 (expr -> expr * expr .)
    ]               reduce using rule 6 (expr -> expr * expr .)
    END             reduce using rule 6 (expr -> expr * expr .)
    ELSE            reduce using rule 6 (expr -> expr * expr .)
    TO              reduce using rule 6 (expr -> expr * expr .)
    }               reduce using rule 6 (expr -> expr * expr .)
    IN              reduce using rule 6 (expr -> expr * expr .)
    TYPE            reduce using rule 6 (expr -> expr * expr .)
    VAR             reduce using rule 6 (expr -> expr * expr .)
    FUNCTION        reduce using rule 6 (expr -> expr * expr .)

  ! +               [ shift and go to state 20 ]
  ! -               [ shift and go to state 21 ]
  ! *               [ shift and go to state 22 ]
  ! /               [ shift and go to state 23 ]
  ! NEQ             [ shift and go to state 24 ]
  ! LE              [ shift and go to state 25 ]
  ! GE              [ shift and go to state 26 ]
  ! =               [ shift and go to state 27 ]
  ! <               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 57

    (7) expr -> expr / expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    +               reduce using rule 7 (expr -> expr / expr .)
    -               reduce using rule 7 (expr -> expr / expr .)
    *               reduce using rule 7 (expr -> expr / expr .)
    /               reduce using rule 7 (expr -> expr / expr .)
    NEQ             reduce using rule 7 (expr -> expr / expr .)
    LE              reduce using rule 7 (expr -> expr / expr .)
    GE              reduce using rule 7 (expr -> expr / expr .)
    =               reduce using rule 7 (expr -> expr / expr .)
    <               reduce using rule 7 (expr -> expr / expr .)
    >               reduce using rule 7 (expr -> expr / expr .)
    |               reduce using rule 7 (expr -> expr / expr .)
    &               reduce using rule 7 (expr -> expr / expr .)
    error           reduce using rule 7 (expr -> expr / expr .)
    $end            reduce using rule 7 (expr -> expr / expr .)
    ;               reduce using rule 7 (expr -> expr / expr .)
    )               reduce using rule 7 (expr -> expr / expr .)
    THEN            reduce using rule 7 (expr -> expr / expr .)
    DO              reduce using rule 7 (expr -> expr / expr .)
    ,               reduce using rule 7 (expr -> expr / expr .)
    ]               reduce using rule 7 (expr -> expr / expr .)
    END             reduce using rule 7 (expr -> expr / expr .)
    ELSE            reduce using rule 7 (expr -> expr / expr .)
    TO              reduce using rule 7 (expr -> expr / expr .)
    }               reduce using rule 7 (expr -> expr / expr .)
    IN              reduce using rule 7 (expr -> expr / expr .)
    TYPE            reduce using rule 7 (expr -> expr / expr .)
    VAR             reduce using rule 7 (expr -> expr / expr .)
    FUNCTION        reduce using rule 7 (expr -> expr / expr .)

  ! +               [ shift and go to state 20 ]
  ! -               [ shift and go to state 21 ]
  ! *               [ shift and go to state 22 ]
  ! /               [ shift and go to state 23 ]
  ! NEQ             [ shift and go to state 24 ]
  ! LE              [ shift and go to state 25 ]
  ! GE              [ shift and go to state 26 ]
  ! =               [ shift and go to state 27 ]
  ! <               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 58

    (8) expr -> expr NEQ expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    NEQ             reduce using rule 8 (expr -> expr NEQ expr .)
    LE              reduce using rule 8 (expr -> expr NEQ expr .)
    GE              reduce using rule 8 (expr -> expr NEQ expr .)
    =               reduce using rule 8 (expr -> expr NEQ expr .)
    <               reduce using rule 8 (expr -> expr NEQ expr .)
    >               reduce using rule 8 (expr -> expr NEQ expr .)
    |               reduce using rule 8 (expr -> expr NEQ expr .)
    &               reduce using rule 8 (expr -> expr NEQ expr .)
    error           reduce using rule 8 (expr -> expr NEQ expr .)
    $end            reduce using rule 8 (expr -> expr NEQ expr .)
    ;               reduce using rule 8 (expr -> expr NEQ expr .)
    )               reduce using rule 8 (expr -> expr NEQ expr .)
    THEN            reduce using rule 8 (expr -> expr NEQ expr .)
    DO              reduce using rule 8 (expr -> expr NEQ expr .)
    ,               reduce using rule 8 (expr -> expr NEQ expr .)
    ]               reduce using rule 8 (expr -> expr NEQ expr .)
    END             reduce using rule 8 (expr -> expr NEQ expr .)
    ELSE            reduce using rule 8 (expr -> expr NEQ expr .)
    TO              reduce using rule 8 (expr -> expr NEQ expr .)
    }               reduce using rule 8 (expr -> expr NEQ expr .)
    IN              reduce using rule 8 (expr -> expr NEQ expr .)
    TYPE            reduce using rule 8 (expr -> expr NEQ expr .)
    VAR             reduce using rule 8 (expr -> expr NEQ expr .)
    FUNCTION        reduce using rule 8 (expr -> expr NEQ expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23

  ! +               [ reduce using rule 8 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 8 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 8 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 8 (expr -> expr NEQ expr .) ]
  ! NEQ             [ shift and go to state 24 ]
  ! LE              [ shift and go to state 25 ]
  ! GE              [ shift and go to state 26 ]
  ! =               [ shift and go to state 27 ]
  ! <               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 59

    (9) expr -> expr LE expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    NEQ             reduce using rule 9 (expr -> expr LE expr .)
    LE              reduce using rule 9 (expr -> expr LE expr .)
    GE              reduce using rule 9 (expr -> expr LE expr .)
    =               reduce using rule 9 (expr -> expr LE expr .)
    <               reduce using rule 9 (expr -> expr LE expr .)
    >               reduce using rule 9 (expr -> expr LE expr .)
    |               reduce using rule 9 (expr -> expr LE expr .)
    &               reduce using rule 9 (expr -> expr LE expr .)
    error           reduce using rule 9 (expr -> expr LE expr .)
    $end            reduce using rule 9 (expr -> expr LE expr .)
    ;               reduce using rule 9 (expr -> expr LE expr .)
    )               reduce using rule 9 (expr -> expr LE expr .)
    THEN            reduce using rule 9 (expr -> expr LE expr .)
    DO              reduce using rule 9 (expr -> expr LE expr .)
    ,               reduce using rule 9 (expr -> expr LE expr .)
    ]               reduce using rule 9 (expr -> expr LE expr .)
    END             reduce using rule 9 (expr -> expr LE expr .)
    ELSE            reduce using rule 9 (expr -> expr LE expr .)
    TO              reduce using rule 9 (expr -> expr LE expr .)
    }               reduce using rule 9 (expr -> expr LE expr .)
    IN              reduce using rule 9 (expr -> expr LE expr .)
    TYPE            reduce using rule 9 (expr -> expr LE expr .)
    VAR             reduce using rule 9 (expr -> expr LE expr .)
    FUNCTION        reduce using rule 9 (expr -> expr LE expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23

  ! +               [ reduce using rule 9 (expr -> expr LE expr .) ]
  ! -               [ reduce using rule 9 (expr -> expr LE expr .) ]
  ! *               [ reduce using rule 9 (expr -> expr LE expr .) ]
  ! /               [ reduce using rule 9 (expr -> expr LE expr .) ]
  ! NEQ             [ shift and go to state 24 ]
  ! LE              [ shift and go to state 25 ]
  ! GE              [ shift and go to state 26 ]
  ! =               [ shift and go to state 27 ]
  ! <               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 60

    (10) expr -> expr GE expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    NEQ             reduce using rule 10 (expr -> expr GE expr .)
    LE              reduce using rule 10 (expr -> expr GE expr .)
    GE              reduce using rule 10 (expr -> expr GE expr .)
    =               reduce using rule 10 (expr -> expr GE expr .)
    <               reduce using rule 10 (expr -> expr GE expr .)
    >               reduce using rule 10 (expr -> expr GE expr .)
    |               reduce using rule 10 (expr -> expr GE expr .)
    &               reduce using rule 10 (expr -> expr GE expr .)
    error           reduce using rule 10 (expr -> expr GE expr .)
    $end            reduce using rule 10 (expr -> expr GE expr .)
    ;               reduce using rule 10 (expr -> expr GE expr .)
    )               reduce using rule 10 (expr -> expr GE expr .)
    THEN            reduce using rule 10 (expr -> expr GE expr .)
    DO              reduce using rule 10 (expr -> expr GE expr .)
    ,               reduce using rule 10 (expr -> expr GE expr .)
    ]               reduce using rule 10 (expr -> expr GE expr .)
    END             reduce using rule 10 (expr -> expr GE expr .)
    ELSE            reduce using rule 10 (expr -> expr GE expr .)
    TO              reduce using rule 10 (expr -> expr GE expr .)
    }               reduce using rule 10 (expr -> expr GE expr .)
    IN              reduce using rule 10 (expr -> expr GE expr .)
    TYPE            reduce using rule 10 (expr -> expr GE expr .)
    VAR             reduce using rule 10 (expr -> expr GE expr .)
    FUNCTION        reduce using rule 10 (expr -> expr GE expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23

  ! +               [ reduce using rule 10 (expr -> expr GE expr .) ]
  ! -               [ reduce using rule 10 (expr -> expr GE expr .) ]
  ! *               [ reduce using rule 10 (expr -> expr GE expr .) ]
  ! /               [ reduce using rule 10 (expr -> expr GE expr .) ]
  ! NEQ             [ shift and go to state 24 ]
  ! LE              [ shift and go to state 25 ]
  ! GE              [ shift and go to state 26 ]
  ! =               [ shift and go to state 27 ]
  ! <               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 61

    (11) expr -> expr = expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    NEQ             reduce using rule 11 (expr -> expr = expr .)
    LE              reduce using rule 11 (expr -> expr = expr .)
    GE              reduce using rule 11 (expr -> expr = expr .)
    =               reduce using rule 11 (expr -> expr = expr .)
    <               reduce using rule 11 (expr -> expr = expr .)
    >               reduce using rule 11 (expr -> expr = expr .)
    |               reduce using rule 11 (expr -> expr = expr .)
    &               reduce using rule 11 (expr -> expr = expr .)
    error           reduce using rule 11 (expr -> expr = expr .)
    $end            reduce using rule 11 (expr -> expr = expr .)
    ;               reduce using rule 11 (expr -> expr = expr .)
    )               reduce using rule 11 (expr -> expr = expr .)
    THEN            reduce using rule 11 (expr -> expr = expr .)
    DO              reduce using rule 11 (expr -> expr = expr .)
    ,               reduce using rule 11 (expr -> expr = expr .)
    ]               reduce using rule 11 (expr -> expr = expr .)
    END             reduce using rule 11 (expr -> expr = expr .)
    ELSE            reduce using rule 11 (expr -> expr = expr .)
    TO              reduce using rule 11 (expr -> expr = expr .)
    }               reduce using rule 11 (expr -> expr = expr .)
    IN              reduce using rule 11 (expr -> expr = expr .)
    TYPE            reduce using rule 11 (expr -> expr = expr .)
    VAR             reduce using rule 11 (expr -> expr = expr .)
    FUNCTION        reduce using rule 11 (expr -> expr = expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23

  ! +               [ reduce using rule 11 (expr -> expr = expr .) ]
  ! -               [ reduce using rule 11 (expr -> expr = expr .) ]
  ! *               [ reduce using rule 11 (expr -> expr = expr .) ]
  ! /               [ reduce using rule 11 (expr -> expr = expr .) ]
  ! NEQ             [ shift and go to state 24 ]
  ! LE              [ shift and go to state 25 ]
  ! GE              [ shift and go to state 26 ]
  ! =               [ shift and go to state 27 ]
  ! <               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 62

    (12) expr -> expr < expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    NEQ             reduce using rule 12 (expr -> expr < expr .)
    LE              reduce using rule 12 (expr -> expr < expr .)
    GE              reduce using rule 12 (expr -> expr < expr .)
    =               reduce using rule 12 (expr -> expr < expr .)
    <               reduce using rule 12 (expr -> expr < expr .)
    >               reduce using rule 12 (expr -> expr < expr .)
    |               reduce using rule 12 (expr -> expr < expr .)
    &               reduce using rule 12 (expr -> expr < expr .)
    error           reduce using rule 12 (expr -> expr < expr .)
    $end            reduce using rule 12 (expr -> expr < expr .)
    ;               reduce using rule 12 (expr -> expr < expr .)
    )               reduce using rule 12 (expr -> expr < expr .)
    THEN            reduce using rule 12 (expr -> expr < expr .)
    DO              reduce using rule 12 (expr -> expr < expr .)
    ,               reduce using rule 12 (expr -> expr < expr .)
    ]               reduce using rule 12 (expr -> expr < expr .)
    END             reduce using rule 12 (expr -> expr < expr .)
    ELSE            reduce using rule 12 (expr -> expr < expr .)
    TO              reduce using rule 12 (expr -> expr < expr .)
    }               reduce using rule 12 (expr -> expr < expr .)
    IN              reduce using rule 12 (expr -> expr < expr .)
    TYPE            reduce using rule 12 (expr -> expr < expr .)
    VAR             reduce using rule 12 (expr -> expr < expr .)
    FUNCTION        reduce using rule 12 (expr -> expr < expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23

  ! +               [ reduce using rule 12 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 12 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 12 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 12 (expr -> expr < expr .) ]
  ! NEQ             [ shift and go to state 24 ]
  ! LE              [ shift and go to state 25 ]
  ! GE              [ shift and go to state 26 ]
  ! =               [ shift and go to state 27 ]
  ! <               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 63

    (13) expr -> expr > expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    NEQ             reduce using rule 13 (expr -> expr > expr .)
    LE              reduce using rule 13 (expr -> expr > expr .)
    GE              reduce using rule 13 (expr -> expr > expr .)
    =               reduce using rule 13 (expr -> expr > expr .)
    <               reduce using rule 13 (expr -> expr > expr .)
    >               reduce using rule 13 (expr -> expr > expr .)
    |               reduce using rule 13 (expr -> expr > expr .)
    &               reduce using rule 13 (expr -> expr > expr .)
    error           reduce using rule 13 (expr -> expr > expr .)
    $end            reduce using rule 13 (expr -> expr > expr .)
    ;               reduce using rule 13 (expr -> expr > expr .)
    )               reduce using rule 13 (expr -> expr > expr .)
    THEN            reduce using rule 13 (expr -> expr > expr .)
    DO              reduce using rule 13 (expr -> expr > expr .)
    ,               reduce using rule 13 (expr -> expr > expr .)
    ]               reduce using rule 13 (expr -> expr > expr .)
    END             reduce using rule 13 (expr -> expr > expr .)
    ELSE            reduce using rule 13 (expr -> expr > expr .)
    TO              reduce using rule 13 (expr -> expr > expr .)
    }               reduce using rule 13 (expr -> expr > expr .)
    IN              reduce using rule 13 (expr -> expr > expr .)
    TYPE            reduce using rule 13 (expr -> expr > expr .)
    VAR             reduce using rule 13 (expr -> expr > expr .)
    FUNCTION        reduce using rule 13 (expr -> expr > expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23

  ! +               [ reduce using rule 13 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 13 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 13 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 13 (expr -> expr > expr .) ]
  ! NEQ             [ shift and go to state 24 ]
  ! LE              [ shift and go to state 25 ]
  ! GE              [ shift and go to state 26 ]
  ! =               [ shift and go to state 27 ]
  ! <               [ shift and go to state 28 ]
  ! >               [ shift and go to state 29 ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 64

    (14) expr -> expr | expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    |               reduce using rule 14 (expr -> expr | expr .)
    error           reduce using rule 14 (expr -> expr | expr .)
    $end            reduce using rule 14 (expr -> expr | expr .)
    ;               reduce using rule 14 (expr -> expr | expr .)
    )               reduce using rule 14 (expr -> expr | expr .)
    THEN            reduce using rule 14 (expr -> expr | expr .)
    DO              reduce using rule 14 (expr -> expr | expr .)
    ,               reduce using rule 14 (expr -> expr | expr .)
    ]               reduce using rule 14 (expr -> expr | expr .)
    END             reduce using rule 14 (expr -> expr | expr .)
    ELSE            reduce using rule 14 (expr -> expr | expr .)
    TO              reduce using rule 14 (expr -> expr | expr .)
    }               reduce using rule 14 (expr -> expr | expr .)
    IN              reduce using rule 14 (expr -> expr | expr .)
    TYPE            reduce using rule 14 (expr -> expr | expr .)
    VAR             reduce using rule 14 (expr -> expr | expr .)
    FUNCTION        reduce using rule 14 (expr -> expr | expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    &               shift and go to state 31

  ! +               [ reduce using rule 14 (expr -> expr | expr .) ]
  ! -               [ reduce using rule 14 (expr -> expr | expr .) ]
  ! *               [ reduce using rule 14 (expr -> expr | expr .) ]
  ! /               [ reduce using rule 14 (expr -> expr | expr .) ]
  ! NEQ             [ reduce using rule 14 (expr -> expr | expr .) ]
  ! LE              [ reduce using rule 14 (expr -> expr | expr .) ]
  ! GE              [ reduce using rule 14 (expr -> expr | expr .) ]
  ! =               [ reduce using rule 14 (expr -> expr | expr .) ]
  ! <               [ reduce using rule 14 (expr -> expr | expr .) ]
  ! >               [ reduce using rule 14 (expr -> expr | expr .) ]
  ! &               [ reduce using rule 14 (expr -> expr | expr .) ]
  ! |               [ shift and go to state 30 ]


state 65

    (15) expr -> expr & expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    |               reduce using rule 15 (expr -> expr & expr .)
    &               reduce using rule 15 (expr -> expr & expr .)
    error           reduce using rule 15 (expr -> expr & expr .)
    $end            reduce using rule 15 (expr -> expr & expr .)
    ;               reduce using rule 15 (expr -> expr & expr .)
    )               reduce using rule 15 (expr -> expr & expr .)
    THEN            reduce using rule 15 (expr -> expr & expr .)
    DO              reduce using rule 15 (expr -> expr & expr .)
    ,               reduce using rule 15 (expr -> expr & expr .)
    ]               reduce using rule 15 (expr -> expr & expr .)
    END             reduce using rule 15 (expr -> expr & expr .)
    ELSE            reduce using rule 15 (expr -> expr & expr .)
    TO              reduce using rule 15 (expr -> expr & expr .)
    }               reduce using rule 15 (expr -> expr & expr .)
    IN              reduce using rule 15 (expr -> expr & expr .)
    TYPE            reduce using rule 15 (expr -> expr & expr .)
    VAR             reduce using rule 15 (expr -> expr & expr .)
    FUNCTION        reduce using rule 15 (expr -> expr & expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29

  ! +               [ reduce using rule 15 (expr -> expr & expr .) ]
  ! -               [ reduce using rule 15 (expr -> expr & expr .) ]
  ! *               [ reduce using rule 15 (expr -> expr & expr .) ]
  ! /               [ reduce using rule 15 (expr -> expr & expr .) ]
  ! NEQ             [ reduce using rule 15 (expr -> expr & expr .) ]
  ! LE              [ reduce using rule 15 (expr -> expr & expr .) ]
  ! GE              [ reduce using rule 15 (expr -> expr & expr .) ]
  ! =               [ reduce using rule 15 (expr -> expr & expr .) ]
  ! <               [ reduce using rule 15 (expr -> expr & expr .) ]
  ! >               [ reduce using rule 15 (expr -> expr & expr .) ]
  ! |               [ shift and go to state 30 ]
  ! &               [ shift and go to state 31 ]


state 66

    (29) expr -> lvalue ASSIGN expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    error           reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    $end            reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    ;               reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    )               reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    THEN            reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    DO              reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    ,               reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    ]               reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    END             reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    ELSE            reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    TO              reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    }               reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    IN              reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    TYPE            reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    VAR             reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    FUNCTION        reduce using rule 29 (expr -> lvalue ASSIGN expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31

  ! +               [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]
  ! -               [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]
  ! *               [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]
  ! /               [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]
  ! NEQ             [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]
  ! LE              [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]
  ! GE              [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]
  ! =               [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]
  ! <               [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]
  ! >               [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]
  ! |               [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]
  ! &               [ reduce using rule 29 (expr -> lvalue ASSIGN expr .) ]


state 67

    (28) fieldExp -> lvalue . ID .

    [               reduce using rule 28 (fieldExp -> lvalue . ID .)
    ASSIGN          reduce using rule 28 (fieldExp -> lvalue . ID .)
    .               reduce using rule 28 (fieldExp -> lvalue . ID .)
    +               reduce using rule 28 (fieldExp -> lvalue . ID .)
    -               reduce using rule 28 (fieldExp -> lvalue . ID .)
    *               reduce using rule 28 (fieldExp -> lvalue . ID .)
    /               reduce using rule 28 (fieldExp -> lvalue . ID .)
    NEQ             reduce using rule 28 (fieldExp -> lvalue . ID .)
    LE              reduce using rule 28 (fieldExp -> lvalue . ID .)
    GE              reduce using rule 28 (fieldExp -> lvalue . ID .)
    =               reduce using rule 28 (fieldExp -> lvalue . ID .)
    <               reduce using rule 28 (fieldExp -> lvalue . ID .)
    >               reduce using rule 28 (fieldExp -> lvalue . ID .)
    |               reduce using rule 28 (fieldExp -> lvalue . ID .)
    &               reduce using rule 28 (fieldExp -> lvalue . ID .)
    error           reduce using rule 28 (fieldExp -> lvalue . ID .)
    $end            reduce using rule 28 (fieldExp -> lvalue . ID .)
    ;               reduce using rule 28 (fieldExp -> lvalue . ID .)
    )               reduce using rule 28 (fieldExp -> lvalue . ID .)
    THEN            reduce using rule 28 (fieldExp -> lvalue . ID .)
    DO              reduce using rule 28 (fieldExp -> lvalue . ID .)
    ,               reduce using rule 28 (fieldExp -> lvalue . ID .)
    ]               reduce using rule 28 (fieldExp -> lvalue . ID .)
    END             reduce using rule 28 (fieldExp -> lvalue . ID .)
    ELSE            reduce using rule 28 (fieldExp -> lvalue . ID .)
    TO              reduce using rule 28 (fieldExp -> lvalue . ID .)
    }               reduce using rule 28 (fieldExp -> lvalue . ID .)
    IN              reduce using rule 28 (fieldExp -> lvalue . ID .)
    TYPE            reduce using rule 28 (fieldExp -> lvalue . ID .)
    VAR             reduce using rule 28 (fieldExp -> lvalue . ID .)
    FUNCTION        reduce using rule 28 (fieldExp -> lvalue . ID .)


state 68

    (30) expr -> ( exprSemiStar ) .

    +               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    -               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    *               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    /               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    NEQ             reduce using rule 30 (expr -> ( exprSemiStar ) .)
    LE              reduce using rule 30 (expr -> ( exprSemiStar ) .)
    GE              reduce using rule 30 (expr -> ( exprSemiStar ) .)
    =               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    <               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    >               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    |               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    &               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    error           reduce using rule 30 (expr -> ( exprSemiStar ) .)
    $end            reduce using rule 30 (expr -> ( exprSemiStar ) .)
    ;               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    )               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    THEN            reduce using rule 30 (expr -> ( exprSemiStar ) .)
    DO              reduce using rule 30 (expr -> ( exprSemiStar ) .)
    ,               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    ]               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    END             reduce using rule 30 (expr -> ( exprSemiStar ) .)
    ELSE            reduce using rule 30 (expr -> ( exprSemiStar ) .)
    TO              reduce using rule 30 (expr -> ( exprSemiStar ) .)
    }               reduce using rule 30 (expr -> ( exprSemiStar ) .)
    IN              reduce using rule 30 (expr -> ( exprSemiStar ) .)
    TYPE            reduce using rule 30 (expr -> ( exprSemiStar ) .)
    VAR             reduce using rule 30 (expr -> ( exprSemiStar ) .)
    FUNCTION        reduce using rule 30 (expr -> ( exprSemiStar ) .)


state 69

    (65) exprSemiPlus -> exprSemiPlus ; . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 89
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 70

    (66) exprSemiPlus -> exprSemiPlus error .

    ;               reduce using rule 66 (exprSemiPlus -> exprSemiPlus error .)
    error           reduce using rule 66 (exprSemiPlus -> exprSemiPlus error .)
    )               reduce using rule 66 (exprSemiPlus -> exprSemiPlus error .)
    END             reduce using rule 66 (exprSemiPlus -> exprSemiPlus error .)


state 71

    (31) expr -> ID ( exprCommaStar . )

    )               shift and go to state 90


state 72

    (68) exprCommaStar -> exprCommaPlus .
    (70) exprCommaPlus -> exprCommaPlus . , expr

    )               reduce using rule 68 (exprCommaStar -> exprCommaPlus .)
    ,               shift and go to state 91


state 73

    (69) exprCommaPlus -> expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    ,               reduce using rule 69 (exprCommaPlus -> expr .)
    )               reduce using rule 69 (exprCommaPlus -> expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 74

    (32) expr -> ID [ expr . ] OF expr
    (27) subscript -> ID [ expr . ]
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    ]               shift and go to state 92
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 75

    (34) fieldCreate -> ID . = expr

    =               shift and go to state 93


state 76

    (33) expr -> ID { fieldCreateCommaStar . }

    }               shift and go to state 94


state 77

    (58) fieldCreateCommaStar -> fieldCreateCommaPlus .
    (60) fieldCreateCommaPlus -> fieldCreateCommaPlus . , fieldCreate

    }               reduce using rule 58 (fieldCreateCommaStar -> fieldCreateCommaPlus .)
    ,               shift and go to state 95


state 78

    (59) fieldCreateCommaPlus -> fieldCreate .

    ,               reduce using rule 59 (fieldCreateCommaPlus -> fieldCreate .)
    }               reduce using rule 59 (fieldCreateCommaPlus -> fieldCreate .)


state 79

    (35) expr -> IF expr THEN . expr
    (36) expr -> IF expr THEN . expr ELSE expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 96
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 80

    (37) expr -> WHILE expr DO . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 97
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 81

    (38) expr -> FOR ID ASSIGN . expr TO expr DO expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 98
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 82

    (39) expr -> LET decPlus IN . exprSemiStar END
    (61) exprSemiStar -> .
    (62) exprSemiStar -> . exprSemiPlus
    (63) exprSemiPlus -> . expr
    (64) exprSemiPlus -> . error
    (65) exprSemiPlus -> . exprSemiPlus ; expr
    (66) exprSemiPlus -> . exprSemiPlus error
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    END             reduce using rule 61 (exprSemiStar -> .)
    error           shift and go to state 39
    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    exprSemiStar                   shift and go to state 99
    exprSemiPlus                   shift and go to state 37
    expr                           shift and go to state 38
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 83

    (55) decPlus -> decPlus dec .

    IN              reduce using rule 55 (decPlus -> decPlus dec .)
    error           reduce using rule 55 (decPlus -> decPlus dec .)
    TYPE            reduce using rule 55 (decPlus -> decPlus dec .)
    VAR             reduce using rule 55 (decPlus -> decPlus dec .)
    FUNCTION        reduce using rule 55 (decPlus -> decPlus dec .)


state 84

    (56) decPlus -> decPlus error .

    IN              reduce using rule 56 (decPlus -> decPlus error .)
    error           reduce using rule 56 (decPlus -> decPlus error .)
    TYPE            reduce using rule 56 (decPlus -> decPlus error .)
    VAR             reduce using rule 56 (decPlus -> decPlus error .)
    FUNCTION        reduce using rule 56 (decPlus -> decPlus error .)


state 85

    (40) dec -> TYPE ID . = ty

    =               shift and go to state 100


state 86

    (41) dec -> VAR ID . ASSIGN expr
    (42) dec -> VAR ID . : ID ASSIGN expr

    ASSIGN          shift and go to state 101
    :               shift and go to state 102


state 87

    (43) dec -> FUNCTION ID . ( fieldDecCommaStar ) = expr
    (44) dec -> FUNCTION ID . ( fieldDecCommaStar ) : ID = expr

    (               shift and go to state 103


state 88

    (26) subscript -> complexLValue [ expr . ]
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    ]               shift and go to state 104
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 89

    (65) exprSemiPlus -> exprSemiPlus ; expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    ;               reduce using rule 65 (exprSemiPlus -> exprSemiPlus ; expr .)
    error           reduce using rule 65 (exprSemiPlus -> exprSemiPlus ; expr .)
    )               reduce using rule 65 (exprSemiPlus -> exprSemiPlus ; expr .)
    END             reduce using rule 65 (exprSemiPlus -> exprSemiPlus ; expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 90

    (31) expr -> ID ( exprCommaStar ) .

    +               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    -               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    *               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    /               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    NEQ             reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    LE              reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    GE              reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    =               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    <               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    >               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    |               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    &               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    error           reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    $end            reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    ;               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    )               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    THEN            reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    DO              reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    ,               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    ]               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    END             reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    ELSE            reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    TO              reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    }               reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    IN              reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    TYPE            reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    VAR             reduce using rule 31 (expr -> ID ( exprCommaStar ) .)
    FUNCTION        reduce using rule 31 (expr -> ID ( exprCommaStar ) .)


state 91

    (70) exprCommaPlus -> exprCommaPlus , . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 105
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 92

    (32) expr -> ID [ expr ] . OF expr
    (27) subscript -> ID [ expr ] .

    OF              shift and go to state 106
    [               reduce using rule 27 (subscript -> ID [ expr ] .)
    ASSIGN          reduce using rule 27 (subscript -> ID [ expr ] .)
    .               reduce using rule 27 (subscript -> ID [ expr ] .)
    +               reduce using rule 27 (subscript -> ID [ expr ] .)
    -               reduce using rule 27 (subscript -> ID [ expr ] .)
    *               reduce using rule 27 (subscript -> ID [ expr ] .)
    /               reduce using rule 27 (subscript -> ID [ expr ] .)
    NEQ             reduce using rule 27 (subscript -> ID [ expr ] .)
    LE              reduce using rule 27 (subscript -> ID [ expr ] .)
    GE              reduce using rule 27 (subscript -> ID [ expr ] .)
    =               reduce using rule 27 (subscript -> ID [ expr ] .)
    <               reduce using rule 27 (subscript -> ID [ expr ] .)
    >               reduce using rule 27 (subscript -> ID [ expr ] .)
    |               reduce using rule 27 (subscript -> ID [ expr ] .)
    &               reduce using rule 27 (subscript -> ID [ expr ] .)
    error           reduce using rule 27 (subscript -> ID [ expr ] .)
    $end            reduce using rule 27 (subscript -> ID [ expr ] .)
    ;               reduce using rule 27 (subscript -> ID [ expr ] .)
    )               reduce using rule 27 (subscript -> ID [ expr ] .)
    THEN            reduce using rule 27 (subscript -> ID [ expr ] .)
    DO              reduce using rule 27 (subscript -> ID [ expr ] .)
    ,               reduce using rule 27 (subscript -> ID [ expr ] .)
    ]               reduce using rule 27 (subscript -> ID [ expr ] .)
    END             reduce using rule 27 (subscript -> ID [ expr ] .)
    ELSE            reduce using rule 27 (subscript -> ID [ expr ] .)
    TO              reduce using rule 27 (subscript -> ID [ expr ] .)
    }               reduce using rule 27 (subscript -> ID [ expr ] .)
    IN              reduce using rule 27 (subscript -> ID [ expr ] .)
    TYPE            reduce using rule 27 (subscript -> ID [ expr ] .)
    VAR             reduce using rule 27 (subscript -> ID [ expr ] .)
    FUNCTION        reduce using rule 27 (subscript -> ID [ expr ] .)


state 93

    (34) fieldCreate -> ID = . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 107
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 94

    (33) expr -> ID { fieldCreateCommaStar } .

    +               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    -               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    *               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    /               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    NEQ             reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    LE              reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    GE              reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    =               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    <               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    >               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    |               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    &               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    error           reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    $end            reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    ;               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    )               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    THEN            reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    DO              reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    ,               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    ]               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    END             reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    ELSE            reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    TO              reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    }               reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    IN              reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    TYPE            reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    VAR             reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)
    FUNCTION        reduce using rule 33 (expr -> ID { fieldCreateCommaStar } .)


state 95

    (60) fieldCreateCommaPlus -> fieldCreateCommaPlus , . fieldCreate
    (34) fieldCreate -> . ID = expr

    ID              shift and go to state 75

    fieldCreate                    shift and go to state 108

state 96

    (35) expr -> IF expr THEN expr .
    (36) expr -> IF expr THEN expr . ELSE expr
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    error           reduce using rule 35 (expr -> IF expr THEN expr .)
    $end            reduce using rule 35 (expr -> IF expr THEN expr .)
    ;               reduce using rule 35 (expr -> IF expr THEN expr .)
    )               reduce using rule 35 (expr -> IF expr THEN expr .)
    THEN            reduce using rule 35 (expr -> IF expr THEN expr .)
    DO              reduce using rule 35 (expr -> IF expr THEN expr .)
    ,               reduce using rule 35 (expr -> IF expr THEN expr .)
    ]               reduce using rule 35 (expr -> IF expr THEN expr .)
    END             reduce using rule 35 (expr -> IF expr THEN expr .)
    TO              reduce using rule 35 (expr -> IF expr THEN expr .)
    }               reduce using rule 35 (expr -> IF expr THEN expr .)
    IN              reduce using rule 35 (expr -> IF expr THEN expr .)
    TYPE            reduce using rule 35 (expr -> IF expr THEN expr .)
    VAR             reduce using rule 35 (expr -> IF expr THEN expr .)
    FUNCTION        reduce using rule 35 (expr -> IF expr THEN expr .)
    ELSE            shift and go to state 109
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31

  ! +               [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! -               [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! *               [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! /               [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! NEQ             [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! LE              [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! GE              [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! =               [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! <               [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! >               [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! |               [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! &               [ reduce using rule 35 (expr -> IF expr THEN expr .) ]
  ! ELSE            [ reduce using rule 35 (expr -> IF expr THEN expr .) ]


state 97

    (37) expr -> WHILE expr DO expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    error           reduce using rule 37 (expr -> WHILE expr DO expr .)
    $end            reduce using rule 37 (expr -> WHILE expr DO expr .)
    ;               reduce using rule 37 (expr -> WHILE expr DO expr .)
    )               reduce using rule 37 (expr -> WHILE expr DO expr .)
    THEN            reduce using rule 37 (expr -> WHILE expr DO expr .)
    DO              reduce using rule 37 (expr -> WHILE expr DO expr .)
    ,               reduce using rule 37 (expr -> WHILE expr DO expr .)
    ]               reduce using rule 37 (expr -> WHILE expr DO expr .)
    END             reduce using rule 37 (expr -> WHILE expr DO expr .)
    ELSE            reduce using rule 37 (expr -> WHILE expr DO expr .)
    TO              reduce using rule 37 (expr -> WHILE expr DO expr .)
    }               reduce using rule 37 (expr -> WHILE expr DO expr .)
    IN              reduce using rule 37 (expr -> WHILE expr DO expr .)
    TYPE            reduce using rule 37 (expr -> WHILE expr DO expr .)
    VAR             reduce using rule 37 (expr -> WHILE expr DO expr .)
    FUNCTION        reduce using rule 37 (expr -> WHILE expr DO expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31

  ! +               [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]
  ! -               [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]
  ! *               [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]
  ! /               [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]
  ! NEQ             [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]
  ! LE              [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]
  ! GE              [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]
  ! =               [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]
  ! <               [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]
  ! >               [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]
  ! |               [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]
  ! &               [ reduce using rule 37 (expr -> WHILE expr DO expr .) ]


state 98

    (38) expr -> FOR ID ASSIGN expr . TO expr DO expr
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    TO              shift and go to state 110
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 99

    (39) expr -> LET decPlus IN exprSemiStar . END

    END             shift and go to state 111


state 100

    (40) dec -> TYPE ID = . ty
    (45) ty -> . ID
    (46) ty -> . ARRAY OF ID
    (47) ty -> . { fieldDecCommaStar }

    ID              shift and go to state 112
    ARRAY           shift and go to state 114
    {               shift and go to state 115

    ty                             shift and go to state 113

state 101

    (41) dec -> VAR ID ASSIGN . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 116
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 102

    (42) dec -> VAR ID : . ID ASSIGN expr

    ID              shift and go to state 117


state 103

    (43) dec -> FUNCTION ID ( . fieldDecCommaStar ) = expr
    (44) dec -> FUNCTION ID ( . fieldDecCommaStar ) : ID = expr
    (49) fieldDecCommaStar -> .
    (50) fieldDecCommaStar -> . fieldDecCommaPlus
    (51) fieldDecCommaPlus -> . fieldDec
    (52) fieldDecCommaPlus -> . fieldDecCommaPlus , fieldDec
    (48) fieldDec -> . ID : ID

    )               reduce using rule 49 (fieldDecCommaStar -> .)
    ID              shift and go to state 118

    fieldDecCommaStar              shift and go to state 119
    fieldDecCommaPlus              shift and go to state 120
    fieldDec                       shift and go to state 121

state 104

    (26) subscript -> complexLValue [ expr ] .

    [               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    ASSIGN          reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    .               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    +               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    -               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    *               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    /               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    NEQ             reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    LE              reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    GE              reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    =               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    <               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    >               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    |               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    &               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    error           reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    $end            reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    ;               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    )               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    THEN            reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    DO              reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    ,               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    ]               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    END             reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    ELSE            reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    TO              reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    }               reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    IN              reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    TYPE            reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    VAR             reduce using rule 26 (subscript -> complexLValue [ expr ] .)
    FUNCTION        reduce using rule 26 (subscript -> complexLValue [ expr ] .)


state 105

    (70) exprCommaPlus -> exprCommaPlus , expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    ,               reduce using rule 70 (exprCommaPlus -> exprCommaPlus , expr .)
    )               reduce using rule 70 (exprCommaPlus -> exprCommaPlus , expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 106

    (32) expr -> ID [ expr ] OF . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 122
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 107

    (34) fieldCreate -> ID = expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    ,               reduce using rule 34 (fieldCreate -> ID = expr .)
    }               reduce using rule 34 (fieldCreate -> ID = expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 108

    (60) fieldCreateCommaPlus -> fieldCreateCommaPlus , fieldCreate .

    ,               reduce using rule 60 (fieldCreateCommaPlus -> fieldCreateCommaPlus , fieldCreate .)
    }               reduce using rule 60 (fieldCreateCommaPlus -> fieldCreateCommaPlus , fieldCreate .)


state 109

    (36) expr -> IF expr THEN expr ELSE . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 123
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 110

    (38) expr -> FOR ID ASSIGN expr TO . expr DO expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 124
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 111

    (39) expr -> LET decPlus IN exprSemiStar END .

    +               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    -               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    *               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    /               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    NEQ             reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    LE              reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    GE              reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    =               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    <               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    >               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    |               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    &               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    error           reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    $end            reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    ;               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    )               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    THEN            reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    DO              reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    ,               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    ]               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    END             reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    ELSE            reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    TO              reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    }               reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    IN              reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    TYPE            reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    VAR             reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)
    FUNCTION        reduce using rule 39 (expr -> LET decPlus IN exprSemiStar END .)


state 112

    (45) ty -> ID .

    IN              reduce using rule 45 (ty -> ID .)
    error           reduce using rule 45 (ty -> ID .)
    TYPE            reduce using rule 45 (ty -> ID .)
    VAR             reduce using rule 45 (ty -> ID .)
    FUNCTION        reduce using rule 45 (ty -> ID .)


state 113

    (40) dec -> TYPE ID = ty .

    IN              reduce using rule 40 (dec -> TYPE ID = ty .)
    error           reduce using rule 40 (dec -> TYPE ID = ty .)
    TYPE            reduce using rule 40 (dec -> TYPE ID = ty .)
    VAR             reduce using rule 40 (dec -> TYPE ID = ty .)
    FUNCTION        reduce using rule 40 (dec -> TYPE ID = ty .)


state 114

    (46) ty -> ARRAY . OF ID

    OF              shift and go to state 125


state 115

    (47) ty -> { . fieldDecCommaStar }
    (49) fieldDecCommaStar -> .
    (50) fieldDecCommaStar -> . fieldDecCommaPlus
    (51) fieldDecCommaPlus -> . fieldDec
    (52) fieldDecCommaPlus -> . fieldDecCommaPlus , fieldDec
    (48) fieldDec -> . ID : ID

    }               reduce using rule 49 (fieldDecCommaStar -> .)
    ID              shift and go to state 118

    fieldDecCommaStar              shift and go to state 126
    fieldDecCommaPlus              shift and go to state 120
    fieldDec                       shift and go to state 121

state 116

    (41) dec -> VAR ID ASSIGN expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    IN              reduce using rule 41 (dec -> VAR ID ASSIGN expr .)
    error           reduce using rule 41 (dec -> VAR ID ASSIGN expr .)
    TYPE            reduce using rule 41 (dec -> VAR ID ASSIGN expr .)
    VAR             reduce using rule 41 (dec -> VAR ID ASSIGN expr .)
    FUNCTION        reduce using rule 41 (dec -> VAR ID ASSIGN expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 117

    (42) dec -> VAR ID : ID . ASSIGN expr

    ASSIGN          shift and go to state 127


state 118

    (48) fieldDec -> ID . : ID

    :               shift and go to state 128


state 119

    (43) dec -> FUNCTION ID ( fieldDecCommaStar . ) = expr
    (44) dec -> FUNCTION ID ( fieldDecCommaStar . ) : ID = expr

    )               shift and go to state 129


state 120

    (50) fieldDecCommaStar -> fieldDecCommaPlus .
    (52) fieldDecCommaPlus -> fieldDecCommaPlus . , fieldDec

    )               reduce using rule 50 (fieldDecCommaStar -> fieldDecCommaPlus .)
    }               reduce using rule 50 (fieldDecCommaStar -> fieldDecCommaPlus .)
    ,               shift and go to state 130


state 121

    (51) fieldDecCommaPlus -> fieldDec .

    ,               reduce using rule 51 (fieldDecCommaPlus -> fieldDec .)
    )               reduce using rule 51 (fieldDecCommaPlus -> fieldDec .)
    }               reduce using rule 51 (fieldDecCommaPlus -> fieldDec .)


state 122

    (32) expr -> ID [ expr ] OF expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    error           reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    $end            reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    ;               reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    )               reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    THEN            reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    DO              reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    ,               reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    ]               reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    END             reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    ELSE            reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    TO              reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    }               reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    IN              reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    TYPE            reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    VAR             reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    FUNCTION        reduce using rule 32 (expr -> ID [ expr ] OF expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31

  ! +               [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]
  ! -               [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]
  ! *               [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]
  ! /               [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]
  ! NEQ             [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]
  ! LE              [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]
  ! GE              [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]
  ! =               [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]
  ! <               [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]
  ! >               [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]
  ! |               [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]
  ! &               [ reduce using rule 32 (expr -> ID [ expr ] OF expr .) ]


state 123

    (36) expr -> IF expr THEN expr ELSE expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    error           reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    $end            reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    ;               reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    )               reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    THEN            reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    DO              reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    ,               reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    ]               reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    END             reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    ELSE            reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    TO              reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    }               reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    IN              reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    TYPE            reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    VAR             reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    FUNCTION        reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31

  ! +               [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]
  ! -               [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]
  ! *               [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]
  ! /               [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]
  ! NEQ             [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]
  ! LE              [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]
  ! GE              [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]
  ! =               [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]
  ! <               [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]
  ! >               [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]
  ! |               [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]
  ! &               [ reduce using rule 36 (expr -> IF expr THEN expr ELSE expr .) ]


state 124

    (38) expr -> FOR ID ASSIGN expr TO expr . DO expr
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    DO              shift and go to state 131
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 125

    (46) ty -> ARRAY OF . ID

    ID              shift and go to state 132


state 126

    (47) ty -> { fieldDecCommaStar . }

    }               shift and go to state 133


state 127

    (42) dec -> VAR ID : ID ASSIGN . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 134
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 128

    (48) fieldDec -> ID : . ID

    ID              shift and go to state 135


state 129

    (43) dec -> FUNCTION ID ( fieldDecCommaStar ) . = expr
    (44) dec -> FUNCTION ID ( fieldDecCommaStar ) . : ID = expr

    =               shift and go to state 136
    :               shift and go to state 137


state 130

    (52) fieldDecCommaPlus -> fieldDecCommaPlus , . fieldDec
    (48) fieldDec -> . ID : ID

    ID              shift and go to state 118

    fieldDec                       shift and go to state 138

state 131

    (38) expr -> FOR ID ASSIGN expr TO expr DO . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 139
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 132

    (46) ty -> ARRAY OF ID .

    IN              reduce using rule 46 (ty -> ARRAY OF ID .)
    error           reduce using rule 46 (ty -> ARRAY OF ID .)
    TYPE            reduce using rule 46 (ty -> ARRAY OF ID .)
    VAR             reduce using rule 46 (ty -> ARRAY OF ID .)
    FUNCTION        reduce using rule 46 (ty -> ARRAY OF ID .)


state 133

    (47) ty -> { fieldDecCommaStar } .

    IN              reduce using rule 47 (ty -> { fieldDecCommaStar } .)
    error           reduce using rule 47 (ty -> { fieldDecCommaStar } .)
    TYPE            reduce using rule 47 (ty -> { fieldDecCommaStar } .)
    VAR             reduce using rule 47 (ty -> { fieldDecCommaStar } .)
    FUNCTION        reduce using rule 47 (ty -> { fieldDecCommaStar } .)


state 134

    (42) dec -> VAR ID : ID ASSIGN expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    IN              reduce using rule 42 (dec -> VAR ID : ID ASSIGN expr .)
    error           reduce using rule 42 (dec -> VAR ID : ID ASSIGN expr .)
    TYPE            reduce using rule 42 (dec -> VAR ID : ID ASSIGN expr .)
    VAR             reduce using rule 42 (dec -> VAR ID : ID ASSIGN expr .)
    FUNCTION        reduce using rule 42 (dec -> VAR ID : ID ASSIGN expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 135

    (48) fieldDec -> ID : ID .

    ,               reduce using rule 48 (fieldDec -> ID : ID .)
    )               reduce using rule 48 (fieldDec -> ID : ID .)
    }               reduce using rule 48 (fieldDec -> ID : ID .)


state 136

    (43) dec -> FUNCTION ID ( fieldDecCommaStar ) = . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 140
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 137

    (44) dec -> FUNCTION ID ( fieldDecCommaStar ) : . ID = expr

    ID              shift and go to state 141


state 138

    (52) fieldDecCommaPlus -> fieldDecCommaPlus , fieldDec .

    ,               reduce using rule 52 (fieldDecCommaPlus -> fieldDecCommaPlus , fieldDec .)
    )               reduce using rule 52 (fieldDecCommaPlus -> fieldDecCommaPlus , fieldDec .)
    }               reduce using rule 52 (fieldDecCommaPlus -> fieldDecCommaPlus , fieldDec .)


state 139

    (38) expr -> FOR ID ASSIGN expr TO expr DO expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    error           reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    $end            reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    ;               reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    )               reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    THEN            reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    DO              reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    ,               reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    ]               reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    END             reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    ELSE            reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    TO              reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    }               reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    IN              reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    TYPE            reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    VAR             reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    FUNCTION        reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31

  ! +               [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]
  ! -               [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]
  ! *               [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]
  ! /               [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]
  ! NEQ             [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]
  ! LE              [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]
  ! GE              [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]
  ! =               [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]
  ! <               [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]
  ! >               [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]
  ! |               [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]
  ! &               [ reduce using rule 38 (expr -> FOR ID ASSIGN expr TO expr DO expr .) ]


state 140

    (43) dec -> FUNCTION ID ( fieldDecCommaStar ) = expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    IN              reduce using rule 43 (dec -> FUNCTION ID ( fieldDecCommaStar ) = expr .)
    error           reduce using rule 43 (dec -> FUNCTION ID ( fieldDecCommaStar ) = expr .)
    TYPE            reduce using rule 43 (dec -> FUNCTION ID ( fieldDecCommaStar ) = expr .)
    VAR             reduce using rule 43 (dec -> FUNCTION ID ( fieldDecCommaStar ) = expr .)
    FUNCTION        reduce using rule 43 (dec -> FUNCTION ID ( fieldDecCommaStar ) = expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31


state 141

    (44) dec -> FUNCTION ID ( fieldDecCommaStar ) : ID . = expr

    =               shift and go to state 142


state 142

    (44) dec -> FUNCTION ID ( fieldDecCommaStar ) : ID = . expr
    (4) expr -> . expr + expr
    (5) expr -> . expr - expr
    (6) expr -> . expr * expr
    (7) expr -> . expr / expr
    (8) expr -> . expr NEQ expr
    (9) expr -> . expr LE expr
    (10) expr -> . expr GE expr
    (11) expr -> . expr = expr
    (12) expr -> . expr < expr
    (13) expr -> . expr > expr
    (14) expr -> . expr | expr
    (15) expr -> . expr & expr
    (16) expr -> . NIL
    (17) expr -> . BREAK
    (18) expr -> . - expr
    (19) expr -> . INT
    (20) expr -> . STRING
    (21) expr -> . lvalue
    (29) expr -> . lvalue ASSIGN expr
    (30) expr -> . ( exprSemiStar )
    (31) expr -> . ID ( exprCommaStar )
    (32) expr -> . ID [ expr ] OF expr
    (33) expr -> . ID { fieldCreateCommaStar }
    (35) expr -> . IF expr THEN expr
    (36) expr -> . IF expr THEN expr ELSE expr
    (37) expr -> . WHILE expr DO expr
    (38) expr -> . FOR ID ASSIGN expr TO expr DO expr
    (39) expr -> . LET decPlus IN exprSemiStar END
    (22) lvalue -> . ID
    (23) lvalue -> . complexLValue
    (24) complexLValue -> . subscript
    (25) complexLValue -> . fieldExp
    (26) subscript -> . complexLValue [ expr ]
    (27) subscript -> . ID [ expr ]
    (28) fieldExp -> . lvalue . ID

    NIL             shift and go to state 5
    BREAK           shift and go to state 6
    -               shift and go to state 4
    INT             shift and go to state 7
    STRING          shift and go to state 8
    (               shift and go to state 10
    ID              shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    LET             shift and go to state 15

    expr                           shift and go to state 143
    lvalue                         shift and go to state 9
    complexLValue                  shift and go to state 16
    subscript                      shift and go to state 17
    fieldExp                       shift and go to state 18

state 143

    (44) dec -> FUNCTION ID ( fieldDecCommaStar ) : ID = expr .
    (4) expr -> expr . + expr
    (5) expr -> expr . - expr
    (6) expr -> expr . * expr
    (7) expr -> expr . / expr
    (8) expr -> expr . NEQ expr
    (9) expr -> expr . LE expr
    (10) expr -> expr . GE expr
    (11) expr -> expr . = expr
    (12) expr -> expr . < expr
    (13) expr -> expr . > expr
    (14) expr -> expr . | expr
    (15) expr -> expr . & expr

    IN              reduce using rule 44 (dec -> FUNCTION ID ( fieldDecCommaStar ) : ID = expr .)
    error           reduce using rule 44 (dec -> FUNCTION ID ( fieldDecCommaStar ) : ID = expr .)
    TYPE            reduce using rule 44 (dec -> FUNCTION ID ( fieldDecCommaStar ) : ID = expr .)
    VAR             reduce using rule 44 (dec -> FUNCTION ID ( fieldDecCommaStar ) : ID = expr .)
    FUNCTION        reduce using rule 44 (dec -> FUNCTION ID ( fieldDecCommaStar ) : ID = expr .)
    +               shift and go to state 20
    -               shift and go to state 21
    *               shift and go to state 22
    /               shift and go to state 23
    NEQ             shift and go to state 24
    LE              shift and go to state 25
    GE              shift and go to state 26
    =               shift and go to state 27
    <               shift and go to state 28
    >               shift and go to state 29
    |               shift and go to state 30
    &               shift and go to state 31

